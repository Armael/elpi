This file is OUTDATED
=====================

Weird syntax of Teyjus:
- no syntax for negative numbers: ~ 2 is the unary minus applied to 2,
  not the number -2.
- \^['@'-'z'] ???
  \OCTAL \OCTALOCTALOCTAL \xHEX \xHEXHEX
  \\\n
  \xxxxxxx\  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  \\cxxxxxx  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  eof should be an error
  \x followed by other combinations should be an error
  \ followed by other combinations should be an error

Departures from Teyjus due to camlp5 idiosynchrasies:
- non-associative infix/prefix/postfix behave like their associative
  counterparts. In particular, if @@ and @@@ are two prefix operators
  with @@ > @@@ then (@@ @@@ @@ @@@ a) is parsed nevertheless
- we parse the elements of lists at level 120, that is the first level used
  in pervasives after 110, the level of ","
- i<, r+, etc. are polymorphic in elpi
- Teyjus admits  x :: : type l  and  x = : type y; we don't.
- if the file ends (without eol) inside a comment, the parser ignores the
  comment (in place of returning an error). How??? Same if the query is not
  . terminated.
- elpi accumulates each file once; Teyjus does it multiple times, that is
  always bad (all clauses are duplicated and tried multiple times, that is
  rarely the expected behaviour)
- Teyjus uses TJPATH; we use TJPATH + accumulate "../foo", resolving
  relative paths according to the path of the accumulating file first or,
  if it fails, according to the TJPATH

MODULES:
- backward compatibility with Teyjus with modules
- document local/sigma in the manual
- name capturing semantics also useful?
- implement import? requires to easily compute the list of free
  names used in a file
- implement ==>? what should be the semantics and scope of fixity
  declarations? E.g. X = accumulate M, X ==> x+y

Documentation:
- see "Departures from Teyjus"
- integers are 31 bits (25 bits in Teyjus); floats are...
- no beta-redexes in the source code
- semantics of ; departed from Teyjus
- semantics of import/accumulate simpler than in Teyjus (no renaming, no
  scoping)
- we accepts generic terms as rules in a .mod/.elpi file.
  All free uppercase variables are turned into existential variables.
  All lowercase ones into universal variables.
  NOTE: check what Teyjus really does now in the main branch.
- strings should not contain newlines; instead
  \n, \b, \t, \r, \\, \", \', "" should be recognized (the last two synonyms)
  <NOT IMPLEMENTED YET>
  \^['@'-'z'] ???
  \OCTAL \OCTALOCTALOCTAL \xHEX \xHEXHEX
  \\\n
  \xxxxxxx\  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  \\cxxxxxx  where xxx are [ ' ' | '\t' | '\x0b' | '\x0d' ]
  eof should be an error
  \x followed by other combinations should be an error
  \ followed by other combinations should be an error
  </NOT IMPLEMENTED YET>

Major Bugs:
- pi X\ (main A :- X = A, $print X).  Anomaly
- string_to_term is severely bugged:
  * we pass the empty amap when parsing/heapifying the string,
    because we do not have them available. Therefore the function works
    as expected only on meta-closed terms.

Minor Bugs (mostly forward compatibility with Teyjus):
- the parser should verify the well-balancing of { }
  There is also a TODO about it in runtime.ml
- readterm flushes the rest of the line, even if it should not.
  One of the misteries of camlp5, I suppose :-(
  FIX: as the spec says, we should first read all characters up to dot,
  then parse. Issue: real numbers are problematic :-(
- capture all Invalid_arg exceptions in custom.ml
- capture all exceptions raised from the parser in custom.ml
  (functions string_to_term and readterm)
- revise all remaining assert false, e.g. in parser
- symbols can be declared twice (e.g. in .mod and in .sig): check and avoid
  inserting a duplicated rule. Also issues a camlp5 warning when it happens
  (e.g. in pcf test)
- handle the NotInProlog exception properly
- a precedence level can change associativity if the user declares a symbol
  with it with a new associativity. This is should be avoided, also because
  the pretty-printer does not change the associativity of old symbols.
  Maybe re-use the map used for set_precedence/precedence_of
- we do not check the first argument of "is" and other predicates
- LaTeX exporter:
  0) local ignored
  1) a Parser.term which contains LaTeX reserved symbols such 
     as "_", "$", etc. should be exported accordingly
  2) it should be implemented a better clausify function and 
     some cases such as nested lambda, pi or impl should be considered.
  3) There should be a uniqe naming of the fresh vars which come from pi.
     For the time being they are named as: v_1, v_2, etc.

Other:

0. pretty-printing to LaTeX + transformation to standard presentation
   (with fresh variables, etc.)
Possible optimizations:

-4. TODO for flatten_snd: benchmark
-3. compare Big Endian vs Little Endian Patricia Trees
-2. diff + to_list can be implemented more efficiently saving all the
    n log n merges and replacing them with an accumulator
-1. if full_deref only works on heap terms, why do we pass all that stuff?
    why not calling deref instead?
0. Try alternative implementation for ?n == ?n
   (i.e. go back to the previous unif code, but change to_heap/restrict)
   NOTE: in the WAM the check is for free. An uninstantiated variable
   points to itsefl. So X=X is implemented making X points to X, i.e.
   leaving X uninstantiated. We cannot do that easily for two reasons:
   a) Fields of a constructor cannot be mutated in ocaml <=4.3.
   b) Our variables can occur multiple times applied to different arguments.
      To exploit the WAM's representation we should replace our
      UVar of ... * term list with a UApp (UVar ..., term list) but then
      we need a deep pattern matching everywhere and this could slow down
      again.
   TO BE TRIED (??)
2. the to_heap could keep the highest non-bound variable to be cached in
   the UVar to make restriction linear
